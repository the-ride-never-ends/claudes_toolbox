import unittest
import tempfile
import os
import shutil
from pathlib import Path
from unittest.mock import patch, mock_open
import stat
from tools.functions.make_a_master_todo_file import make_a_master_todo_file


class TestMakeAMasterTodoFile(unittest.TestCase):
    """Test make_a_master_todo_file function for creating TODO lists from Python directories."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()
        self.output_path = os.path.join(self.temp_dir, "master_todo.md")
        
    def tearDown(self):
        """Clean up test fixtures."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_create_todo_file_with_valid_directory_and_output_path(self):
        """
        GIVEN a valid directory path containing Python files with:
            - Multiple .py files
            - Classes with methods
            - Standalone functions
            - Mix of public and private methods
        AND a valid output path with write permissions
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Function returns the output_path string
            - A markdown file is created at output_path
            - File contains directory header with analyzed path
            - File contains generation timestamp
            - File contains hierarchical TODO list with all Python files
            - Each callable has sub-tasks for stubs, tests, and implementation
        """
        # Create test Python files
        file1_content = '''
class TestClass:
    def public_method(self):
        pass
    
    def _private_method(self):
        pass

def standalone_function():
    pass
'''
        
        file2_content = '''
class AnotherClass:
    def another_method(self):
        pass

def another_function():
    pass
'''
        
        file1_path = os.path.join(self.temp_dir, "file1.py")
        file2_path = os.path.join(self.temp_dir, "file2.py")
        
        with open(file1_path, 'w') as f:
            f.write(file1_content)
        with open(file2_path, 'w') as f:
            f.write(file2_content)
        
        # Call the function
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        # Verify return value
        self.assertEqual(result, self.output_path)
        
        # Verify file was created
        self.assertTrue(os.path.exists(self.output_path))
        
        # Read and verify content
        with open(self.output_path, 'r') as f:
            content = f.read()
        
        # Check for required sections
        self.assertIn(f"# Directory: {self.temp_dir}", content)
        self.assertIn("# Master TODO List", content)
        self.assertIn("# Autogenerated on", content)
        
        # Check for Python files
        self.assertIn("file1.py", content)
        self.assertIn("file2.py", content)
        
        # Check for classes and methods
        self.assertIn("TestClass", content)
        self.assertIn("AnotherClass", content)
        self.assertIn("public_method", content)
        self.assertIn("_private_method", content)
        self.assertIn("another_method", content)
        
        # Check for standalone functions
        self.assertIn("standalone_function", content)
        self.assertIn("another_function", content)
        
        # Check for sub-tasks
        self.assertIn("Write function stub with type hints", content)
        self.assertIn("Write test that calls the actual", content)
        self.assertIn("Run all tests to confirm they fail", content)

    def test_directory_not_found(self):
        """
        GIVEN a directory_path that does not exist
        WHEN make_a_master_todo_file is called
        THEN expect FileNotFoundError to be raised
        """
        non_existent_path = "/path/that/does/not/exist"
        
        with self.assertRaises(FileNotFoundError):
            make_a_master_todo_file(non_existent_path, self.output_path)

    def test_directory_permission_denied(self):
        """
        GIVEN a directory_path that exists but user lacks read permissions
        WHEN make_a_master_todo_file is called
        THEN expect PermissionError to be raised
        """
        # Create a directory and remove read permissions
        restricted_dir = os.path.join(self.temp_dir, "restricted")
        os.makedirs(restricted_dir)
        
        # Remove read permissions (Unix-like systems)
        if os.name != 'nt':  # Not Windows
            os.chmod(restricted_dir, stat.S_IWRITE)
            
            with self.assertRaises(PermissionError):
                make_a_master_todo_file(restricted_dir, self.output_path)
            
            # Restore permissions for cleanup
            os.chmod(restricted_dir, stat.S_IREAD | stat.S_IWRITE | stat.S_IEXEC)
        else:
            # Skip this test on Windows as permission handling is different
            self.skipTest("Permission testing not implemented for Windows")

    def test_output_path_permission_denied(self):
        """
        GIVEN a valid directory_path
        AND an output_path where user lacks write permissions
        WHEN make_a_master_todo_file is called
        THEN expect PermissionError to be raised
        """
        # Create a Python file in temp directory
        test_file = os.path.join(self.temp_dir, "test.py")
        with open(test_file, 'w') as f:
            f.write("def test_func(): pass")
        
        # Try to write to a restricted location
        if os.name != 'nt':  # Not Windows
            restricted_output = "/root/restricted_output.md"
            
            with self.assertRaises(PermissionError):
                make_a_master_todo_file(self.temp_dir, restricted_output)
        else:
            # Skip this test on Windows
            self.skipTest("Permission testing not implemented for Windows")

    def test_invalid_directory_path(self):
        """
        GIVEN a directory_path that is invalid (e.g., empty string, None, or malformed)
        WHEN make_a_master_todo_file is called
        THEN expect ValueError to be raised
        """
        invalid_paths = ["", None, "   ", "\0invalid"]
        
        for invalid_path in invalid_paths:
            with self.assertRaises((ValueError, TypeError)):
                make_a_master_todo_file(invalid_path, self.output_path)

    def test_directory_with_no_python_files(self):
        """
        GIVEN a valid directory_path that contains no Python files
        WHEN make_a_master_todo_file is called
        THEN expect ValueError to be raised
        """
        # Create some non-Python files
        txt_file = os.path.join(self.temp_dir, "readme.txt")
        js_file = os.path.join(self.temp_dir, "script.js")
        
        with open(txt_file, 'w') as f:
            f.write("This is a text file")
        with open(js_file, 'w') as f:
            f.write("console.log('Hello world');")
        
        with self.assertRaises(ValueError):
            make_a_master_todo_file(self.temp_dir, self.output_path)

    def test_nested_directory_structure(self):
        """
        GIVEN a directory with nested subdirectories containing Python files
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Function returns the output_path string
            - TODO file includes all Python files from all subdirectories
            - File paths in TODO maintain directory structure
        """
        # Create nested structure
        subdir1 = os.path.join(self.temp_dir, "subdir1")
        subdir2 = os.path.join(self.temp_dir, "subdir2")
        os.makedirs(subdir1)
        os.makedirs(subdir2)
        
        # Create Python files in different locations
        root_file = os.path.join(self.temp_dir, "root.py")
        sub1_file = os.path.join(subdir1, "sub1.py")
        sub2_file = os.path.join(subdir2, "sub2.py")
        
        for file_path in [root_file, sub1_file, sub2_file]:
            with open(file_path, 'w') as f:
                f.write("def test_func(): pass")
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        self.assertTrue(os.path.exists(self.output_path))
        
        with open(self.output_path, 'r') as f:
            content = f.read()
        
        # Check that all files are included
        self.assertIn("root.py", content)
        self.assertIn("sub1.py", content)
        self.assertIn("sub2.py", content)

    def test_empty_python_files(self):
        """
        GIVEN a directory containing empty Python files (no classes/functions)
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Function returns the output_path string
            - TODO file lists the empty Python files
            - No sub-items under empty files
        """
        # Create empty Python files
        empty_file1 = os.path.join(self.temp_dir, "empty1.py")
        empty_file2 = os.path.join(self.temp_dir, "empty2.py")
        
        with open(empty_file1, 'w') as f:
            f.write("")
        with open(empty_file2, 'w') as f:
            f.write("# Just a comment\n")
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        self.assertTrue(os.path.exists(self.output_path))
        
        with open(self.output_path, 'r') as f:
            content = f.read()
        
        # Files should be listed
        self.assertIn("empty1.py", content)
        self.assertIn("empty2.py", content)

    def test_python_files_with_syntax_errors(self):
        """
        GIVEN a directory containing Python files with syntax errors
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Function either skips the problematic files or handles gracefully
            - Other valid Python files are still processed
            - Function returns the output_path string
        """
        # Create a file with syntax error
        bad_file = os.path.join(self.temp_dir, "bad_syntax.py")
        with open(bad_file, 'w') as f:
            f.write("def broken_function(\n    # Missing closing parenthesis")
        
        # Create a valid file
        good_file = os.path.join(self.temp_dir, "good_syntax.py")
        with open(good_file, 'w') as f:
            f.write("def good_function(): pass")
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        self.assertTrue(os.path.exists(self.output_path))
        
        with open(self.output_path, 'r') as f:
            content = f.read()
        
        # Good file should be processed
        self.assertIn("good_syntax.py", content)
        self.assertIn("good_function", content)

    def test_special_method_handling(self):
        """
        GIVEN Python files containing special methods like __init__, __str__, etc.
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Special methods are included in the TODO list
            - They follow the same task structure as regular methods
        """
        test_file = os.path.join(self.temp_dir, "special_methods.py")
        content = '''
class TestClass:
    def __init__(self):
        pass
    
    def __str__(self):
        pass
    
    def __repr__(self):
        pass
    
    def regular_method(self):
        pass
'''
        
        with open(test_file, 'w') as f:
            f.write(content)
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        
        with open(self.output_path, 'r') as f:
            todo_content = f.read()
        
        # Check for special methods
        self.assertIn("__init__", todo_content)
        self.assertIn("__str__", todo_content)
        self.assertIn("__repr__", todo_content)
        self.assertIn("regular_method", todo_content)

    def test_decorated_functions_and_methods(self):
        """
        GIVEN Python files with decorated functions and methods (@property, @staticmethod, etc.)
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Decorated callables are included in the TODO list
            - They follow the same task structure as regular callables
        """
        test_file = os.path.join(self.temp_dir, "decorated.py")
        content = '''
class TestClass:
    @property
    def prop_method(self):
        pass
    
    @staticmethod
    def static_method():
        pass
    
    @classmethod
    def class_method(cls):
        pass

@property
def decorated_function():
    pass
'''
        
        with open(test_file, 'w') as f:
            f.write(content)
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        
        with open(self.output_path, 'r') as f:
            todo_content = f.read()
        
        # Check for decorated methods
        self.assertIn("prop_method", todo_content)
        self.assertIn("static_method", todo_content)
        self.assertIn("class_method", todo_content)
        self.assertIn("decorated_function", todo_content)

    def test_output_file_already_exists(self):
        """
        GIVEN a valid directory_path
        AND an output_path where a file already exists
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Existing file is overwritten
            - Function returns the output_path string
        """
        # Create a test Python file
        test_file = os.path.join(self.temp_dir, "test.py")
        with open(test_file, 'w') as f:
            f.write("def test_func(): pass")
        
        # Create existing output file
        with open(self.output_path, 'w') as f:
            f.write("Old content that should be overwritten")
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        
        # Verify file was overwritten
        with open(self.output_path, 'r') as f:
            content = f.read()
        
        self.assertNotIn("Old content that should be overwritten", content)
        self.assertIn("test_func", content)

    def test_very_large_directory(self):
        """
        GIVEN a directory with hundreds of Python files and thousands of callables
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Function completes successfully (performance test)
            - All files and callables are included
            - Function returns the output_path string
        """
        # Create a reasonable number of files for testing (not hundreds for speed)
        num_files = 50
        methods_per_class = 10
        
        for i in range(num_files):
            file_path = os.path.join(self.temp_dir, f"file_{i}.py")
            content = f'''
class TestClass{i}:
'''
            for j in range(methods_per_class):
                content += f'''    def method_{j}(self):
        pass
    
'''
            
            with open(file_path, 'w') as f:
                f.write(content)
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        self.assertTrue(os.path.exists(self.output_path))
        
        with open(self.output_path, 'r') as f:
            content = f.read()
        
        # Check that files are included
        self.assertIn("file_0.py", content)
        self.assertIn("file_49.py", content)
        self.assertIn("TestClass0", content)
        self.assertIn("TestClass49", content)

    def test_unicode_and_special_characters_in_names(self):
        """
        GIVEN Python files with Unicode characters or special characters in:
            - File names
            - Class names
            - Method/function names
        WHEN make_a_master_todo_file is called
        THEN expect:
            - All names are properly handled and displayed in the TODO file
            - No encoding errors occur
            - Function returns the output_path string
        """
        # Create file with Unicode characters
        unicode_file = os.path.join(self.temp_dir, "测试文件.py")
        content = '''
class 测试类:
    def 测试方法(self):
        pass
    
    def método_español(self):
        pass

def función_test():
    pass
'''
        
        with open(unicode_file, 'w', encoding='utf-8') as f:
            f.write(content)
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        
        with open(self.output_path, 'r', encoding='utf-8') as f:
            todo_content = f.read()
        
        # Check for Unicode content
        self.assertIn("测试文件.py", todo_content)
        self.assertIn("测试类", todo_content)
        self.assertIn("测试方法", todo_content)
        self.assertIn("método_español", todo_content)
        self.assertIn("función_test", todo_content)

    def test_async_functions_and_methods(self):
        """
        GIVEN Python files containing async functions and async methods
        WHEN make_a_master_todo_file is called
        THEN expect:
            - Async callables are included in the TODO list
            - They follow the same task structure as regular callables
        """
        test_file = os.path.join(self.temp_dir, "async_test.py")
        content = '''
class AsyncClass:
    async def async_method(self):
        pass
    
    def regular_method(self):
        pass

async def async_function():
    pass

def regular_function():
    pass
'''
        
        with open(test_file, 'w') as f:
            f.write(content)
        
        result = make_a_master_todo_file(self.temp_dir, self.output_path)
        
        self.assertEqual(result, self.output_path)
        
        with open(self.output_path, 'r') as f:
            todo_content = f.read()
        
        # Check for async callables
        self.assertIn("async_method", todo_content)
        self.assertIn("async_function", todo_content)
        self.assertIn("regular_method", todo_content)
        self.assertIn("regular_function", todo_content)


if __name__ == '__main__':
    unittest.main()